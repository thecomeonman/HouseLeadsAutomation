pass_success_pct_d.o := completed_passes.o / attempted_passes.o
][,
# big_chances_missed_pct := big_chances_missed / big_chances_created
# ][,
errors_leading_to_goal_or_attempt_d.o := ( errors_leading_to_goal.o + errors_leading_to_goal_attempt.o )
# ][,
# goals_from_error_pct_d := errors_leading_to_goal / goals_conceded
][,
# c('shots_d','shots_d.o') := list(target_missed + saves.o + goals_scored, target_missed.o + saves + goals_scored.o)
][,
# c('shots_conversion_pct_d','shots_conversion_pct_d.o') := list(goals_scored / shots_d, goals_scored.o / shots_d.o)
# ][,
#    c('shots_wasted_d','shots_wasted_d.o') := list(target_missed + saves.o, target_missed.o + saves)
#][,
#   c('shots_wastage_pct_d','shots_wastage_pct_d.o') := list(shots_wasted_d / shots_d, shots_wasted_d.o / shots_d.o)
][,
# key_passes_per_goal.o := key_passes.o / goals_scored.o
]
}
dtAggregation2
}
fLoadData = function(
cFileName = '/media/ask/Data/Personal/FPL/data_before39_1617.Rdata',
cSeason = '16-17'
) {
print(cFileName)
print(cSeason)
if ( cSeason == '17-18' ) {
dtTeamCode = data.table(
team = as.character(1:20),
teamname = c(
'ARS',
'BOU',
'BHA',
'BUR',
'CHE',
'CRY',
'EVE',
'HUD',
'LEI',
'LIV',
'MCI',
'MUN',
'NEW',
'SOU',
'STK',
'SWA',
'TOT',
'WAT',
'WBA',
'WHU'
)
)
} else {
dtTeamCode = data.table(
team = as.character(1:20),
teamname = c(
'ARS',
'BOU',
'BUR',
'CHE',
'CRY',
'EVE',
'HUL',
'LEI',
'LIV',
'MCI',
'MUN',
'MID', # looks like this order from the table, even though it isn't alphabetical - dtTeamMatchData[season == '16-17', list(.N, sum(goals_scored > goals_conceded), sum(goals_scored == goals_conceded)), list(teamname, team)]
'SOU',
'STK',
'SUN',
'SWA',
'TOT',
'WAT',
'WBA',
'WHU'
)
)
}
load(cFileName)
dtPlayerMatchData = rbindlist(lapply(
lAllPlayers,
function( lPlayer ) {
rbindlist(lapply(
lPlayer$history,
function ( lMatch ) {
data.table(t(unlist(lMatch)))
}
))
}
))
dtPlayerMatchData[, season := cSeason]
# converting to numeric whatever can be
# ---------------------------------------------------------------------------
vcColsToConvert = sapply(
dtPlayerMatchData[1,],
function( x ) sum(is.na(as.numeric(as.character(x))))
)
vcMetricCols = names(vcColsToConvert[vcColsToConvert == 0])
vcMetricCols = setdiff(
vcMetricCols,
c(
"team","fixture","opponent_team","id","someotherid",
"team_code","element_type"
)
)
for ( cColToConvert in vcMetricCols ) {
dtPlayerMatchData[, temp123 := as.numeric(as.character(get(cColToConvert)))]
dtPlayerMatchData = dtPlayerMatchData[, !cColToConvert, with = F]
setnames(
dtPlayerMatchData,
'temp123',
cColToConvert
)
}
# ---------------------------------------------------------------------------
# element in this is known as id in the static data.
setnames(
dtPlayerMatchData,
c('id','element'),
c('someotherid','id')
)
# ---------------------------------------------------------------------------
# summer transfer between teams messes up team assignment. fixing
dtMatches = dtPlayerMatchData[,
list(
opponent_team = unique(opponent_team)[1],
team = unique(opponent_team)[2]
),
list(fixture)
]
dtPlayerMatchData = merge(
dtPlayerMatchData,
rbind(
dtMatches,
dtMatches[,
list(
opponent_team = team,
team = opponent_team
),
list(fixture)
]
),
c('fixture','opponent_team'),
all.x = T
)
rm(dtMatches)
if ( exists('lAllPlayersStatic') ) {
dtPlayerMatchData = merge(
dtPlayerMatchData,
rbindlist(lapply(
lAllPlayersStatic$elements,
function( lPlayerStatic ) {
dtPlayerStatic = data.table(
t(
unlist(
lPlayerStatic[
c(
'id',
'photo',
'team_code',
'first_name',
'second_name',
'element_type'
# without all players static, can get team by
# checking opponent for each fixture. Doing
# that for now.
# 'team'
)
]
)
)
)
dtPlayerStatic[, id := as.numeric(as.character(id))]
dtPlayerStatic
}
), fill = T),
'id'
)
} else {
#----------------------------------------------------------------------
# view-source: https://fantasy.premierleague.com/help/
# For 16-17 season
# ~1.7% of the minutes were unaccounted for. Can live with it.
# Drops  to 1% for big six
dtPlayerMatchData[, element_type := as.integer(NA)]
# dtPlayerMatchData2 = copy(dtPlayerMatchData)
# dtPlayerMatchData[minutes < 60 & clean_sheets == 1]
# doesn't return any rows so can be used to figure out players
# Let it be for now. Doesn't matter.
# dtPlayerMatchData = dtPlayerMatchData[minutes > 0]
dtPlayerMatchData[
is.na(element_type) &
id %in% dtPlayerMatchData[
is.na(element_type),
any(
as.integer(saves) > 1
),
id
][
V1 == T,
id
],
element_type := 1L
]
for ( i in 2L:4L ) {
dtPlayerMatchData[
is.na(element_type) &
# minutes > 0 & # redundant condition once goals clean sheet things happen
# the common points one remove and check for other events happening
(
goals_scored > 0 |
clean_sheets > 0
) &
total_points == (
0
+ (minutes > 0) + ( minutes > 60 )
+ ( goals_scored * dtPoints[element_type == i, goals_scored] )
+ ( assists * dtPoints[element_type == i, assists] )
+ ( clean_sheets * dtPoints[element_type == i, clean_sheets] )
+ floor( saves * dtPoints[element_type == i, saves] )
+ ceiling( goals_conceded * dtPoints[element_type == i, goals_conceded] ) # ceiling because negative points
+ ( penalties_missed * dtPoints[element_type == i, penalties_missed] )
+ bonus
+ ( yellow_cards * dtPoints[element_type == i, yellow_cards] )
+ ( red_cards * dtPoints[element_type == i, red_cards] )
+ ( own_goals * dtPoints[element_type == i, own_goals] )
),
element_type := i
]
# they  should all be correct. Once in a while linear combination might
# indicate differently though so ensuring those ones don't stick
dtPlayerMatchData[
# the common points one remove and check for other events happening
(
goals_scored > 0 |
clean_sheets > 0
),
element_type := ifelse(
any(is.na(element_type)),
as.integer(NA),
element_type
),
list(
season,
id
)
]
dtPlayerMatchData[,
element_type := ifelse(
all(is.na(element_type)),
as.integer(NA),
element_type[!is.na(element_type)][1]
),
list(
season,
id
)
]
}
}
# taking care of summer transfesr between teams
# the FPL database overwrites team ID even for pre-transfer matches
# oops, have already done htis before so not needed agains
# dtPlayerMatchData = merge(
#    dtPlayerMatchData[, !'team', with = F],
#    dtPlayerMatchData[, list(.N), list(opponent, team, fixture)][N > 5, list(opponent, team, fixture)],
#    c('fixture','opponent')
# )
dtPlayerMatchData = merge(
dtPlayerMatchData,
dtTeamCode,
'team'
)
dtPlayerMatchData = merge(
dtPlayerMatchData,
dtTeamCode[, list(opponent_team = team, opponentname = teamname)],
'opponent_team'
)
dtPlayerMatchData[, c('opponent_team','team') := NULL]
rm(lAllPlayers)
rm(lAllPlayersStatic)
rm(dtTeamCode)
dtPlayerMatchData = merge(
dtPlayerMatchData,
dtPlayerMatchData[,
list(1),
list(teamname, kickoff_time)
][,
match_nbr := rank(kickoff_time),
teamname
][,
list(
match_nbr,
teamname,
kickoff_time
)
],
c('kickoff_time','teamname'),
all.x = T
)
dtPlayerMatchData[, was_home := as.logical(as.character(was_home))]
vcMetricCols = setdiff(
vcMetricCols,
"round"
)
dtPlayerMatchData[
was_home == TRUE,
c('team_goals','opponent_goals') := list(team_h_score, team_a_score)
]
dtPlayerMatchData[
was_home != TRUE,
c('team_goals','opponent_goals') := list(team_a_score, team_h_score)
]
dtPlayerMatchData[, c('team_a_score', 'team_h_score') := NULL]
}
fPrepareChartList = function (
ggplotTemplate = ggplotTemplate,
dtDatasetMelted = dtTeamDataMelted,
cValueToPlot = 'value_per_90min',
cFacetFormula = NULL
) {
lCharts = lapply(
dtDatasetMelted[, unique(variable)],
function ( cVariable ) {
ggplotValue = ggplotTemplate +
geom_text_repel(
data = dtDatasetMelted[variable %in% cVariable][teamname %in% vcBigSix],
aes_string(
x = 'season',
# y = Estimate,
y = cValueToPlot,
label = 'teamname',
group = 'teamname',
color = 'teamname'
)
) +
geom_point(
data = dtDatasetMelted[variable %in% cVariable],
aes_string(
x = 'season',
# y = Estimate,
y = cValueToPlot,
group = 'teamname',
color = 'teamname'
)
) +
geom_line(
data = dtDatasetMelted[variable %in% cVariable],
aes_string(
x = 'season',
# y = Estimate,
y = cValueToPlot,
group = 'teamname',
color = 'teamname'
)
)
if ( !is.null( cFacetFormula ) ) {
ggplotValue = ggplotValue +
facet_grid(
as.formula(cFacetFormula),
# ncol = 1,
scale = 'free_y'
)
}
if ( grepl(x = cVariable, pattern = '_pct') ) {
ggplotValue = ggplotValue +
scale_y_continuous(labels = percent)  +
labs(
list(
title = paste0(cVariable),
x = 'Season',
y = 'Averaged over the season'
)
)
} else {
ggplotValue = ggplotValue +
labs(
list(
title = paste0(cVariable),
x = 'Season',
y = 'Value per match'
)
)
}
ggplotValue
}
)
names(lCharts) = dtDatasetMelted[, unique(variable)]
lCharts
}
```
```{r DataPreprocessing, echo=F, cache=F, warning = F, message = F, results = 'hide', fig.height = 18, fig.width = 18}
dtPlayerMatchData = rbind(
fLoadData(
cFileName = '/media/ask/Data/Personal/FPL/data_before39_1718.Rdata',
cSeason = '17-18'
),
fLoadData(
cFileName = '/media/ask/Data/Personal/FPL/data_before39_1617.Rdata',
cSeason = '16-17'
),
fill = T
)
rm(list = ls())
cRootDirectory = '/home/ask/Desktop/HouseLeadsAutomation'
setwd(cRootDirectory)
setwd('ScrapingScripts')
sapply(
list.files(),
# grep(x = list.files(), pattern = '99', invert = T, value = T),
function(x) {
print(x)
source(x)
print('Finished. 10 seconds wait because reasons.')
# needed because either the googleSheets package or the authorisation can't process requests very quilckly
Sys.sleep(10)
}
)
rm(list = ls())
cRootDirectory = '/home/ask/Desktop/HouseLeadsAutomation'
setwd(cRootDirectory)
setwd('ScrapingScripts')
sapply(
# list.files(),
grep(x = list.files(), pattern = '99', invert = T, value = T),
function(x) {
print(x)
source(x)
print('Finished. 10 seconds wait because reasons.')
# needed because either the googleSheets package or the authorisation can't process requests very quilckly
Sys.sleep(10)
}
)
dtListings
# Uploading details of the properties back to the Google sheet
# Code is same across websites
# =============================================================================
if ( exists('dtListings') ) {
# Putting old and new entries together
dtListings = rbind(
data.frame(gsListings),
dtListings,
fill = T
)
setDT(dtListings)
# Changing order of columns such that user entered columns come last
setcolorder(
dtListings,
c(
grep(
colnames(dtListings),
pattern = '^ZZ',
value = T,
invert = T
),
grep(
colnames(dtListings),
pattern = '^ZZ',
value = T
)
)
)
# Error values are easier on the eye this way
dtListings[dtListings == 'NULL'] = ''
dtListings[dtListings == 'NA'] = ''
dtListings[is.na(dtListings)] = ''
# Deleting previous sheet and adding data as a new sheet
# This is needed in case there are any new
# columns that go added in this iteration
AHH %>%
gs_ws_delete(ws = cResultsSheetName)
AHH <- gs_title(cFileName)
AHH %>%
gs_ws_new(
ws_title = cResultsSheetName,
input = dtListings,
trim = TRUE,
verbose = FALSE
)
}
AHH %>%
gs_ws_new(
ws_title = cResultsSheetName,
input = dtListings,
trim = TRUE,
verbose = FALSE
)
AHH %>%
gs_ws_new(
ws_title = cResultsSheetName,
input = dtListings,
trim = TRUE,
verbose = FALSE
)
dtListings
write.csv(dtListings, '~/Desktop/MB.csv', quote = F, na = '')
AHH %>%
gs_ws_new(
ws_title = cResultsSheetName,
input = dtListings,
trim = TRUE,
verbose = FALSE
)
AHH %>%
gs_ws_new(
ws_title = cResultsSheetName,
input = dtListings,
trim = TRUE,
verbose = FALSE
)
